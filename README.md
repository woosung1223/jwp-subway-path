# jwp-subway-path

# 페어 프로그래밍 룰

## 스위치 기준

- [x] 스위치 시간은 20분으로 한다.
- [x] 내비게이터는 전자기기에 손을 대지 않는다.

## 깃 컨벤션

- [x] 기능 목록에 있는 기능 단위로 커밋한다.
- [x] 작동할 수 있는 기능 단위로 커밋한다.
- [x] 커밋 메세지는 아래 키워드를 사용해 기능 목록 그대로 작성한다.
    - feat: 기능 구현을 완료했을 때
    - refactor: 기능의 변화 없이 코드를 변경했을 때
    - test: 테스트 코드만 작성했을 때
    - chore: 패키지 변경 등 사소한 수정사항이 생겼을 때
    - fix: 프로그램의 결함을 수정할 때
    - docs: 문서를 수정할 때

## 구현 계획

- [x] 구현은 다음과 같은 순서로 진행된다.
    1. API 설계 시 사용되는 서비스에 대한 기능 파악
    2. 컨트롤러 기능 구현 
    3. 서비스 기능을 담기 위한 도메인 구현
    4. 영속성에 대한 인터페이스 구현(DIP)
    5. 서비스 기능 구현
    6. 영속성 구현체 생성 테이블 정의

## 기타 룰

- [x] 페어 프로그래밍 방식에 대해 논의하고 싶다면 언제든 이야기한다.
- [x] 집중이 안된다면 페어에게 솔직하게 이야기한다.
- [x] 최소한 2시간에 한 번은 쉬어야 한다.
- [x] 커피챗을 최소 1회 진행한다.


---

# 기능 목록

- [x] 노선에 대한 역 등록 API 구현
  - [x] 역의 위치는 자유롭게 지정할 수 있어야 한다.
  - [x] 노선에 역이 등록될 때 거리 정보도 함께 포함되어야 한다.
    - [x] 거리 정보는 양의 정수로 제한한다.
  - [x] 노선에 역이 하나도 등록되지 않은 상황에서 최초 등록 시 두 역을 동시에 등록해야 한다.
  - [x] 이미 존재하는 역에 대해서만 추가 노선을 지정할 수 있다.
  - [x] 하나의 역은 여러 노선에 등록이 될 수 있다.
  - [x] 노선은 갈래길을 가질 수 없다.
  - [x] 노선 가운데 역이 등록 될 경우 거리 정보를 고려해야 한다.
    - [x] 신규로 등록된 역이 기존 노선의 거리 범위를 벗어날 수 없다.
    - [x] A-B-C 노선에서 B 다음에 D 역을 등록하려고 한다면, B-C역의 거리가 3km인 경우 B-D 거리는 3km 보다 적어야 한다.

- [x] 노선에 역 제거 API 구현
  - [x] 노선에서 역을 제거할 경우 정상 동작을 위해 재배치 되어야 한다.
  - [x] 노선에서 역이 제거될 경우 역과 역 사이의 거리가 재배정된다.
  - [x] 노선에 등록된 역이 2개 인 경우 하나의 역을 제거할 때 두 역이 모두 제거되어야 한다.

- [x] 단일 노선 조회 API 구현
  - [x] 노선에 포함된 역을 순서대로 보여주도록 응답을 개선한다.

- [x] 노선 목록 조회 API 구현
  - [x] 각 노선에 포함된 역을 순서대로 보여주도록 응답을 개선한다.


---
# step 1 기록
- [x] `Line` 도메인 엔티티를 CRUD용으로도 사용하기도 하고, 비즈니스 로직을 수행할 때 사용하기도 해서 문제가 많았음.
  - [x] 문제점 1: CRUD 시점에는 완전한 도메인 객체가 아님.
  - [x] 문제점 2: 하나의 도메인 엔티티가 여러 개념을 내포하고 있음.
    - [x] 따라서 `LineProperty` 라는 개념을 분리해 ID를 따로 부여했음. 
    - [x] 두 개념(CRUD, 비즈니스 로직용)은 라이프사이클이 다르기에 같은 도메인 엔티티에 정의되면 굉장히 복잡하기 떄문.
- [x] E2E 테스트 환경에서 사용하는 DataSource를 프로덕션 환경에서 사용하는 DataSource로부터 분리.
  - [x] `@SpringBootTest` 어노테이션은 기본적으로 main에 정의된 DataSource를 사용함.
    - [x] 따라서 `@AutoConfigureTestDatabase`를 통해 Embedded H2 DB를 사용하도록 변경.
    - [x] `@JdbcTest`의 경우 내부적으로 이미 해당 어노테이션이 적용되어 있어 문제가 없음.
- [x] 비즈니스 계층에서 발생하는 예외는 모두 커스텀하게 변경 
  - [x] 예측 가능한 예외를 커스텀하게 변경했을 때의 예상되는 장점은 다음과 같음.
    - [x] 예외 후처리가 쉬워짐. 예외마다 다른 처리를 적용할 수 있다.
    - [x] 예외 객체 하나로도 도메인적 표현이 가능해진다.
    - [x] 다른 라이브러리, 프레임워크에서 발생시키는 예외와 겹칠 일이 없다. (제일 중요한 부분이지 않을까)
  - [x] 하지만 커스텀 예외를 사용하면서 생기는 비용도 무시할 수 없음.
    - [x] 예외 객체까지도 관리포인트가 된다.
    - [x] 예외마다 처리가 달라지는 것이 아니라면 이점이 크게 없을 수 있다.
  - [x] 조금 더 고민해보기.
- [x] "SELECT ... WHERE ... IN" 으로 쿼리 개선
  - [x] 여러 번의 쿼리를 단 한 번의 쿼리로 리스트 형태로 받아올 수 있게 됨
- [x] 어플리케이션 레벨에서 조인과 비슷한 기능을 하는 코드 작성
  - [x] N번 쿼리를 보내야 했던 문제를 1번으로 해결
  - [x] 데이터베이스 레벨에서 조인을 하는 방법도 있을 듯 한데.. 관련 DAO나 Row를 또 한번 만들어줘야 하는 문제점
    - [x] 조인할 때마다 새로운 DAO를 만들 것인가?
- 
